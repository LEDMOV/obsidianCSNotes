[[!2.4 Types of Programming Language]]

## Programming Paradigms

- Programming paradigms are established **conventions** and **practices** that dictate how computer programs are **structured** and **developed**
    
- Programming paradigms offer varied methodologies for software construction
    
- Different paradigms are **suited to different tasks,** e.g. simple web applications can be achieved with light-weight procedural languages, complex enterprise-level software can only be achieved with a complex object-oriented paradigm
    
- New paradigms arise, and existing ones adapt in response to changes in computing and software challenges
    

### Overview of Programming Paradigms

|**Paradigm**|**Description**|**Examples of Languages**|**Key Concepts**|
|---|---|---|---|
|**Procedural**|A subtype of imperative, structured around procedure calls.|C, Go, Rust|Procedures, function calls, structured programming|
|**Object-Oriented**|Organises code around "objects" (which combine data and functionality) rather than functions.|Java, C#, Swift|Classes, inheritance, polymorphism, encapsulation|
|**Assembly**|Low-level mnemonic representation of machine code for a specific computer architecture.|x86-64 Assembly, ARMv8 Assembly|Registers, mnemonics, memory addresses, opcodes|

### Strengths & Weaknesses of Programming Paradigms

|**Paradigm**|**Strengths**|**Weaknesses**|
|---|---|---|
|**Procedural**|- Efficient execution of straightforward tasks<br>    <br>- A clear flow of control (top to bottom)<br>    <br>- Ease of implementation for algorithms<br>    <br>- Strong emphasis on step-by-step procedure execution|- Can become unwieldy for large programs<br>    <br>- Lack of modularity can lead to code redundancy<br>    <br>- Not ideal for applications with complex states or behaviours<br>    <br>- Difficulty in managing and scaling the system as it grows|
|**Object-Oriented**|- Enhances modularity with encapsulation<br>    <br>- Enables real-world modelling using objects<br>    <br>- Code reuse through inheritance<br>    <br>- Polymorphism allows flexibility in interface design|- Can lead to unnecessary complexity<br>    <br>- Inefficiency due to overhead (e.g., memory for objects)<br>    <br>- Not always intuitive for all types of problems<br>    <br>- Misuse can lead to overly complex inheritance hierarchies|
|**Assembly**|- Direct control over hardware<br>    <br>- Optimised performance due to low-level operations<br>    <br>- A transparent understanding of how the machine operates<br>    <br>- Potential for very efficient code|- Extremely steep learning curve<br>    <br>- Hardware-specific, leading to a lack of portability<br>    <br>- Tedious and error-prone due to manual memory management.<br>    <br>- Difficult to write, debug, and maintain large programs|